#!/usr/bin/env python3

# ------------------------------------------------------------------------
import argparse
import abc
import dataclasses
import json
import sys
import pathlib
from typing import Any, Dict, List, Optional, Type


# ------------------------------------------------------------------------
@dataclasses.dataclass
class Binding:
  name: str
  ret: str
  args: List[str]
  imm_bound: Optional[int] = None


# ------------------------------------------------------------------------
OCAML_TYPE: Dict[str, str] = {
  "M128": "T.m128",
  "M128i": "T.m128",
  "M256": "T.m256",
  "M256i": "T.m256",
  "Int8": "int",
  "Int16": "int",
  "Int32": "int32",
  "Int64": "int64",
  "Imm8": "int",
}


# ------------------------------------------------------------------------
class BindingUtils:
  @staticmethod
  def parse_bindings(data: Dict[str, Any]) -> List[Binding]:
    bindings = data.get("bindings")
    if not isinstance(bindings, list):
      raise ValueError("bindings must be a list")

    typed_bindings: List[Binding] = []
    for b in bindings:
      if not isinstance(b, dict):
        raise ValueError("each binding must be an object")
      typed_entry = Binding(
        name=b["name"],
        ret=b["ret"],
        args=b["args"],
        imm_bound=b.get("imm_bound"),
      )
      typed_bindings.append(typed_entry)

    return typed_bindings

  @staticmethod
  def validate_bindings(bindings: List[Binding]) -> None:
    for binding in bindings:
      BindingUtils._validate_binding(binding)

  @staticmethod
  def _validate_binding(binding: Binding) -> None:
    name = binding.name
    ret = binding.ret
    args = binding.args

    if ret not in OCAML_TYPE or ret == "Imm8":
      raise ValueError(f"{name}: invalid return type {ret}")

    if not isinstance(args, list) or len(args) == 0:
      raise ValueError(f"{name}: args must be a non-empty list")

    for arg in args:
      if arg not in OCAML_TYPE:
        raise ValueError(f"{name}: invalid arg type {arg}")

    if binding.imm_bound is not None:
      n = binding.imm_bound
      if not isinstance(n, int) or n <= 0 or n > 256:
        raise ValueError(f"{name}: imm_bound must be in 1..256")
      if args[-1] != "Imm8":
        raise ValueError(f"{name}: imm_bound is only valid with Imm8 as last arg")


# ------------------------------------------------------------------------
class Renderer(abc.ABC):
  @staticmethod
  def generated_header(comment_open: str, comment_close: str) -> List[str]:
    return [
      f"{comment_open} This file is generated by generate_avx2_bindings.py. {comment_close}",
      f"{comment_open} Do not edit by hand; edit bindings.avx2.json instead. {comment_close}",
    ]

  @abc.abstractmethod
  def render(self, bindings: List[Binding]) -> str:
    raise NotImplementedError


# ------------------------------------------------------------------------
class MlRenderer(Renderer):
  @staticmethod
  def ocaml_sig(args: List[str], ret: str) -> str:
    return " -> ".join([OCAML_TYPE[a] for a in args] + [OCAML_TYPE[ret]])

  def render(self, bindings: List[Binding]) -> str:
    lines = [
      *self.generated_header("(*", "*)"),
      "",
      "module Make (T : sig",
      "  type m128",
      "  type m256",
      "end) = struct",
      "",
    ]
    for b in bindings:
      name = b.name
      lines.append(f'  external {name} : {self.ocaml_sig(b.args, b.ret)} = "caml_{name}"')
    lines.append("end")
    lines.append("")
    return "\n".join(lines)


# ------------------------------------------------------------------------
class CppRenderer(Renderer):
  def render(self, bindings: List[Binding]) -> str:
    lines = self.generated_header("/*", "*/")
    for binding in bindings:
      name = binding.name
      ret = binding.ret
      args = binding.args
      if args[-1] == "Imm8":
        imm_bound = binding.imm_bound if binding.imm_bound is not None else "AVX2_BINDC_CASES"
        n = len(args) - 1  # number of non-immediate arguments
        macro = f"BIND{n}C_N"
        non_imm_args = ", ".join(args[:-1])
        lines.append(f"{macro}({name}, {ret}, {non_imm_args}, {imm_bound});")
      else:
        n = len(args)
        macro = f"BIND{n}"
        all_args = ", ".join(args)
        lines.append(f"{macro}({name}, {ret}, {all_args});")
    lines.append("")
    return "\n".join(lines)


# ------------------------------------------------------------------------
RENDERER_TYPES: Dict[str, Type[Renderer]] = {
  "ml": MlRenderer,
  "cpp": CppRenderer,
}


# ------------------------------------------------------------------------
def parse_args() -> argparse.Namespace:
  parser = argparse.ArgumentParser(description="Generate AVX2 bindings from JSON")
  parser.add_argument(
    "--mode",
    required=True,
    choices=sorted(RENDERER_TYPES.keys()),
    help="Output kind to generate",
  )
  parser.add_argument("input_path", type=pathlib.Path, help="Path to bindings.avx2.json")
  parser.add_argument("output_path", type=pathlib.Path, help="Path to generated output file")
  return parser.parse_args()


# ------------------------------------------------------------------------
def main() -> int:
  args = parse_args()

  mode = args.mode
  in_path = args.input_path
  out_path = args.output_path

  data: Dict[str, Any] = json.loads(in_path.read_text())
  typed_bindings = BindingUtils.parse_bindings(data)
  BindingUtils.validate_bindings(typed_bindings)

  if mode not in RENDERER_TYPES:
    allowed_modes = ", ".join(f"'{m}'" for m in sorted(RENDERER_TYPES.keys()))
    raise ValueError(f"mode must be one of {allowed_modes}")

  renderer = RENDERER_TYPES[mode]()
  out = renderer.render(typed_bindings)

  out_path.write_text(out)
  return 0


# ------------------------------------------------------------------------
if __name__ == "__main__":
  raise SystemExit(main())
